// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: booking.sql

package pgdb

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const cancelBooking = `-- name: CancelBooking :exec
UPDATE bookings SET status = 'CANCELLED', cancelled_by = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2
`

type CancelBookingParams struct {
	CancelledBy sql.NullString
	ID          uuid.UUID
}

func (q *Queries) CancelBooking(ctx context.Context, arg CancelBookingParams) error {
	_, err := q.db.ExecContext(ctx, cancelBooking, arg.CancelledBy, arg.ID)
	return err
}

const createBooking = `-- name: CreateBooking :exec
INSERT INTO bookings (id,user_id, captain_id, pickup_location, drop_location, status)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateBookingParams struct {
	ID             uuid.UUID
	UserID         int32
	CaptainID      int32
	PickupLocation string
	DropLocation   string
	Status         NullBookingStatus
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) error {
	_, err := q.db.ExecContext(ctx, createBooking,
		arg.ID,
		arg.UserID,
		arg.CaptainID,
		arg.PickupLocation,
		arg.DropLocation,
		arg.Status,
	)
	return err
}

const deleteBooking = `-- name: DeleteBooking :exec
UPDATE bookings SET deleted_at = $1 WHERE id = $2
`

type DeleteBookingParams struct {
	DeletedAt sql.NullTime
	ID        uuid.UUID
}

func (q *Queries) DeleteBooking(ctx context.Context, arg DeleteBookingParams) error {
	_, err := q.db.ExecContext(ctx, deleteBooking, arg.DeletedAt, arg.ID)
	return err
}

const getBooking = `-- name: GetBooking :one
SELECT id, user_id, captain_id, pickup_location, drop_location, actual_price, paid_price, is_paid, is_successful, is_verified, payment_method, status, is_cancelled, cancelled_by, is_deleted, deleted_at, created_at, updated_at FROM bookings WHERE id = $1 and deleted_at is null
`

func (q *Queries) GetBooking(ctx context.Context, id uuid.UUID) (Booking, error) {
	row := q.db.QueryRowContext(ctx, getBooking, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CaptainID,
		&i.PickupLocation,
		&i.DropLocation,
		&i.ActualPrice,
		&i.PaidPrice,
		&i.IsPaid,
		&i.IsSuccessful,
		&i.IsVerified,
		&i.PaymentMethod,
		&i.Status,
		&i.IsCancelled,
		&i.CancelledBy,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCaptainBookingsByCaptainId = `-- name: GetCaptainBookingsByCaptainId :many
SELECT id, user_id, captain_id, pickup_location, drop_location, actual_price, paid_price, is_paid, is_successful, is_verified, payment_method, status, is_cancelled, cancelled_by, is_deleted, deleted_at, created_at, updated_at FROM bookings WHERE captain_id = $1 and deleted_at is null
`

func (q *Queries) GetCaptainBookingsByCaptainId(ctx context.Context, captainID int32) ([]Booking, error) {
	rows, err := q.db.QueryContext(ctx, getCaptainBookingsByCaptainId, captainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CaptainID,
			&i.PickupLocation,
			&i.DropLocation,
			&i.ActualPrice,
			&i.PaidPrice,
			&i.IsPaid,
			&i.IsSuccessful,
			&i.IsVerified,
			&i.PaymentMethod,
			&i.Status,
			&i.IsCancelled,
			&i.CancelledBy,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentBookingByCaptainId = `-- name: GetCurrentBookingByCaptainId :one
SELECT b.id, b.user_id, b.captain_id, b.pickup_location, b.drop_location, b.actual_price, b.paid_price, b.is_paid, b.is_successful, b.is_verified, b.payment_method, b.status, b.is_cancelled, b.cancelled_by, b.is_deleted, b.deleted_at, b.created_at, b.updated_at FROM bookings b left join captains c on b.captain_id = c.id where b.captain_id = $1
and b.id = c.current_booking_id and b.deleted_at is null
`

func (q *Queries) GetCurrentBookingByCaptainId(ctx context.Context, captainID int32) (Booking, error) {
	row := q.db.QueryRowContext(ctx, getCurrentBookingByCaptainId, captainID)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CaptainID,
		&i.PickupLocation,
		&i.DropLocation,
		&i.ActualPrice,
		&i.PaidPrice,
		&i.IsPaid,
		&i.IsSuccessful,
		&i.IsVerified,
		&i.PaymentMethod,
		&i.Status,
		&i.IsCancelled,
		&i.CancelledBy,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCurrentBookingByUserId = `-- name: GetCurrentBookingByUserId :one
SELECT b.id, b.user_id, b.captain_id, b.pickup_location, b.drop_location, b.actual_price, b.paid_price, b.is_paid, b.is_successful, b.is_verified, b.payment_method, b.status, b.is_cancelled, b.cancelled_by, b.is_deleted, b.deleted_at, b.created_at, b.updated_at FROM bookings b left join user u on b.user_id = u.id where b.user_id = $1
and b.id = u.current_booking_id and b.deleted_at is null
`

func (q *Queries) GetCurrentBookingByUserId(ctx context.Context, userID int32) (Booking, error) {
	row := q.db.QueryRowContext(ctx, getCurrentBookingByUserId, userID)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CaptainID,
		&i.PickupLocation,
		&i.DropLocation,
		&i.ActualPrice,
		&i.PaidPrice,
		&i.IsPaid,
		&i.IsSuccessful,
		&i.IsVerified,
		&i.PaymentMethod,
		&i.Status,
		&i.IsCancelled,
		&i.CancelledBy,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserBookingsByUserId = `-- name: GetUserBookingsByUserId :many
SELECT id, user_id, captain_id, pickup_location, drop_location, actual_price, paid_price, is_paid, is_successful, is_verified, payment_method, status, is_cancelled, cancelled_by, is_deleted, deleted_at, created_at, updated_at FROM bookings WHERE user_id = $1 and deleted_at is null
`

func (q *Queries) GetUserBookingsByUserId(ctx context.Context, userID int32) ([]Booking, error) {
	rows, err := q.db.QueryContext(ctx, getUserBookingsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CaptainID,
			&i.PickupLocation,
			&i.DropLocation,
			&i.ActualPrice,
			&i.PaidPrice,
			&i.IsPaid,
			&i.IsSuccessful,
			&i.IsVerified,
			&i.PaymentMethod,
			&i.Status,
			&i.IsCancelled,
			&i.CancelledBy,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookings = `-- name: ListBookings :many
SELECT id, user_id, captain_id, pickup_location, drop_location, actual_price, paid_price, is_paid, is_successful, is_verified, payment_method, status, is_cancelled, cancelled_by, is_deleted, deleted_at, created_at, updated_at FROM bookings where deleted_at is null
`

func (q *Queries) ListBookings(ctx context.Context) ([]Booking, error) {
	rows, err := q.db.QueryContext(ctx, listBookings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CaptainID,
			&i.PickupLocation,
			&i.DropLocation,
			&i.ActualPrice,
			&i.PaidPrice,
			&i.IsPaid,
			&i.IsSuccessful,
			&i.IsVerified,
			&i.PaymentMethod,
			&i.Status,
			&i.IsCancelled,
			&i.CancelledBy,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockBooking = `-- name: LockBooking :exec
SELECT id, user_id, captain_id, pickup_location, drop_location, actual_price, paid_price, is_paid, is_successful, is_verified, payment_method, status, is_cancelled, cancelled_by, is_deleted, deleted_at, created_at, updated_at FROM bookings WHERE id = $1 FOR UPDATE
`

func (q *Queries) LockBooking(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, lockBooking, id)
	return err
}

const updateBookingCancel = `-- name: UpdateBookingCancel :one
UPDATE bookings SET status = 'CANCELLED',is_cannelled = true, cancelled_by = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2 and is_verified = false RETURNING id, user_id, captain_id, pickup_location, drop_location, actual_price, paid_price, is_paid, is_successful, is_verified, payment_method, status, is_cancelled, cancelled_by, is_deleted, deleted_at, created_at, updated_at
`

type UpdateBookingCancelParams struct {
	CancelledBy sql.NullString
	ID          uuid.UUID
}

func (q *Queries) UpdateBookingCancel(ctx context.Context, arg UpdateBookingCancelParams) (Booking, error) {
	row := q.db.QueryRowContext(ctx, updateBookingCancel, arg.CancelledBy, arg.ID)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CaptainID,
		&i.PickupLocation,
		&i.DropLocation,
		&i.ActualPrice,
		&i.PaidPrice,
		&i.IsPaid,
		&i.IsSuccessful,
		&i.IsVerified,
		&i.PaymentMethod,
		&i.Status,
		&i.IsCancelled,
		&i.CancelledBy,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBookingPayment = `-- name: UpdateBookingPayment :exec
UPDATE bookings SET paid_price = $1, is_paid = $2, payment_method = $3, updated_at = CURRENT_TIMESTAMP WHERE id = $4
`

type UpdateBookingPaymentParams struct {
	PaidPrice     string
	IsPaid        sql.NullBool
	PaymentMethod sql.NullString
	ID            uuid.UUID
}

func (q *Queries) UpdateBookingPayment(ctx context.Context, arg UpdateBookingPaymentParams) error {
	_, err := q.db.ExecContext(ctx, updateBookingPayment,
		arg.PaidPrice,
		arg.IsPaid,
		arg.PaymentMethod,
		arg.ID,
	)
	return err
}

const updateBookingStatus = `-- name: UpdateBookingStatus :exec
UPDATE bookings SET status = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2
`

type UpdateBookingStatusParams struct {
	Status NullBookingStatus
	ID     uuid.UUID
}

func (q *Queries) UpdateBookingStatus(ctx context.Context, arg UpdateBookingStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateBookingStatus, arg.Status, arg.ID)
	return err
}

const updateBookingSucess = `-- name: UpdateBookingSucess :one
UPDATE bookings SET status = 'COMPLETED', is_paid = true, is_successful = true , updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id, user_id, captain_id, pickup_location, drop_location, actual_price, paid_price, is_paid, is_successful, is_verified, payment_method, status, is_cancelled, cancelled_by, is_deleted, deleted_at, created_at, updated_at
`

func (q *Queries) UpdateBookingSucess(ctx context.Context, id uuid.UUID) (Booking, error) {
	row := q.db.QueryRowContext(ctx, updateBookingSucess, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CaptainID,
		&i.PickupLocation,
		&i.DropLocation,
		&i.ActualPrice,
		&i.PaidPrice,
		&i.IsPaid,
		&i.IsSuccessful,
		&i.IsVerified,
		&i.PaymentMethod,
		&i.Status,
		&i.IsCancelled,
		&i.CancelledBy,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBookingVerify = `-- name: UpdateBookingVerify :one
UPDATE bookings SET is_verified = true, updated_at = CURRENT_TIMESTAMP WHERE id = $1 AND status = 'PENDING' AND is_cannelled = false RETURNING id, user_id, captain_id, pickup_location, drop_location, actual_price, paid_price, is_paid, is_successful, is_verified, payment_method, status, is_cancelled, cancelled_by, is_deleted, deleted_at, created_at, updated_at
`

func (q *Queries) UpdateBookingVerify(ctx context.Context, id uuid.UUID) (Booking, error) {
	row := q.db.QueryRowContext(ctx, updateBookingVerify, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CaptainID,
		&i.PickupLocation,
		&i.DropLocation,
		&i.ActualPrice,
		&i.PaidPrice,
		&i.IsPaid,
		&i.IsSuccessful,
		&i.IsVerified,
		&i.PaymentMethod,
		&i.Status,
		&i.IsCancelled,
		&i.CancelledBy,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
